"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircularDepenedencyAwaiter = void 0;
const MultiMap_1 = require("./MultiMap");
const MultiSet_1 = require("./MultiSet");
class CircularDepenedencyAwaiter {
    constructor() {
        this.graphNodes = new MultiMap_1.MultiMap();
    }
    add(subjectItem, subjectItemName, awaitedItem, awaitedItemName, executingPromises) {
        if (executingPromises.get(awaitedItem, awaitedItemName)?.isResolved) {
            return () => {
            };
        }
        if (!this.graphNodes.has(subjectItem, subjectItemName)) {
            this.graphNodes.set(subjectItem, subjectItemName, new MultiSet_1.MultiSet());
        }
        this.graphNodes
            .get(subjectItem, subjectItemName)
            ?.add(awaitedItem, awaitedItemName);
        this.checkForCircuit(awaitedItem, awaitedItemName, subjectItem, subjectItemName);
        return () => {
            const awaitedSet = this.graphNodes.get(subjectItem, subjectItemName);
            awaitedSet?.delete(awaitedItem, awaitedItemName);
            if (awaitedSet?.size === 0) {
                this.graphNodes.delete(subjectItem, subjectItemName);
            }
        };
    }
    checkForCircuit(curItem, curItemName, subjectItem, subjectItemName) {
        const nextNodes = this.graphNodes.get(curItem, curItemName);
        if (!nextNodes) {
            return;
        }
        nextNodes.forEach((nextItem, nextItemName) => {
            if (subjectItem === nextItem && subjectItemName === nextItemName) {
                throw new Error(`Circular dependency found. Use the 'setReturnPointer' function. The loop includes the '${subjectItemName}' type`);
            }
            this.checkForCircuit(nextItem, nextItemName, subjectItem, subjectItemName);
        });
    }
}
exports.CircularDepenedencyAwaiter = CircularDepenedencyAwaiter;
//# sourceMappingURL=CircularDependencyAwaiter.js.map