"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSet = void 0;
class MultiSet {
    constructor() {
        this.map = new Map();
        this.internalSize = 0;
    }
    add(key1, key2) {
        let nestedSet = this.map.get(key1);
        if (!nestedSet) {
            nestedSet = new Set();
            this.map.set(key1, nestedSet);
        }
        if (!nestedSet.has(key2)) {
            this.internalSize++;
        }
        nestedSet.add(key2);
    }
    has(key1, key2) {
        const firstValue = this.map.get(key1);
        if (!firstValue) {
            return false;
        }
        return firstValue.has(key2);
    }
    delete(key1, key2) {
        const nestedSet = this.map.get(key1);
        if (!nestedSet) {
            return;
        }
        if (nestedSet.has(key2)) {
            this.internalSize--;
        }
        nestedSet.delete(key2);
        if (nestedSet.size === 0) {
            this.map.delete(key1);
        }
    }
    get size() {
        return this.internalSize;
    }
    clone() {
        const newMultiSet = new MultiSet();
        this.map.forEach((key2Set, key1) => {
            key2Set.forEach((key2) => {
                newMultiSet.add(key1, key2);
            });
        });
        return newMultiSet;
    }
    toString(key1Transformer = (key) => key, key2Transformer = (key) => key) {
        const multiSetValues = [];
        this.forEach((item1, item2) => {
            multiSetValues.push(`(${key1Transformer(item1)},${key2Transformer(item2)})`);
        });
        return `${multiSetValues.join(",")}`;
    }
    forEach(callback) {
        this.map.forEach((key2Set, key1) => {
            key2Set.forEach((key2) => {
                callback(key1, key2);
            });
        });
    }
}
exports.MultiSet = MultiSet;
//# sourceMappingURL=MultiSet.js.map