"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformer = void 0;
const TransformerParentSubTraverser_1 = require("./transformerSubTraversers/TransformerParentSubTraverser");
const CircularDependencyAwaiter_1 = require("./transformerSubTraversers/util/CircularDependencyAwaiter");
const MultiMap_1 = require("./transformerSubTraversers/util/MultiMap");
const SuperPromise_1 = require("./transformerSubTraversers/util/SuperPromise");
const InstanceGraph_1 = require("../instanceGraph/InstanceGraph");
class Transformer {
    constructor(traverserDefinition, transformers) {
        this.traverserDefinition = traverserDefinition;
        this.transformers = this.applyDefaultTransformers(transformers);
    }
    applyDefaultInterfaceTransformerProperties(typeName, typePropertiesInput) {
        return Object.keys(this.traverserDefinition[typeName]
            .properties).reduce((agg, key) => {
            if (typePropertiesInput && typePropertiesInput[key]) {
                agg[key] = typePropertiesInput[key];
            }
            else {
                agg[key] = (originalData, getTransformedChildren) => {
                    return getTransformedChildren();
                };
            }
            return agg;
        }, {});
    }
    applyDefaultInterfaceTransformer(typeName, typeInput) {
        if (!typeInput) {
            return {
                transformer: async (originalData, getTransformedChildren) => {
                    return getTransformedChildren();
                },
                properties: this.applyDefaultInterfaceTransformerProperties(typeName, {}),
            };
        }
        return {
            transformer: typeInput.transformer,
            properties: this.applyDefaultInterfaceTransformerProperties(typeName, typeInput.properties),
        };
    }
    applyDefaultUnionTransformer(typeInput) {
        if (!typeInput) {
            return async (originalData, getTransformedChildren) => {
                return getTransformedChildren();
            };
        }
        return typeInput;
    }
    applyDefaultPrimitiveTransformer(typeInput) {
        if (!typeInput) {
            return async (originalData) => {
                return originalData;
            };
        }
        return typeInput;
    }
    applyDefaultTransformers(inputTransformers) {
        const finalTansformers = {};
        Object.keys(this.traverserDefinition).forEach((typeName) => {
            if (this.traverserDefinition[typeName].kind === "interface") {
                finalTansformers[typeName] = this.applyDefaultInterfaceTransformer(typeName, inputTransformers[typeName]);
            }
            else if (this.traverserDefinition[typeName].kind === "union") {
                finalTansformers[typeName] = this.applyDefaultUnionTransformer(inputTransformers[typeName]);
            }
            else if (this.traverserDefinition[typeName].kind === "primitive") {
                finalTansformers[typeName] = this.applyDefaultPrimitiveTransformer(inputTransformers[typeName]);
            }
        });
        return finalTansformers;
    }
    async transform(item, itemTypeName, context) {
        const superPromise = new SuperPromise_1.SuperPromise();
        const instanceGraph = new InstanceGraph_1.InstanceGraph(this.traverserDefinition);
        instanceGraph.getNodeFor(item, itemTypeName);
        const toReturn = await (0, TransformerParentSubTraverser_1.transformerParentSubTraverser)(item, itemTypeName, {
            traverserDefinition: this.traverserDefinition,
            transformers: this.transformers,
            executingPromises: new MultiMap_1.MultiMap(),
            circularDependencyAwaiter: new CircularDependencyAwaiter_1.CircularDepenedencyAwaiter(),
            superPromise,
            instanceGraph,
            context,
        });
        await superPromise.wait();
        return toReturn;
    }
}
exports.Transformer = Transformer;
//# sourceMappingURL=Transformer.js.map