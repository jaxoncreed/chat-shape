"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rdf_utils_1 = require("@ldo/rdf-utils");
const readable_stream_1 = require("readable-stream");
class ExtendedDataset {
    constructor(dataset, datasetFactory) {
        this.dataset = dataset;
        this.datasetCoreFactory = datasetFactory;
    }
    createBlankDataset() {
        return new ExtendedDataset(this.datasetCoreFactory.dataset(), this.datasetCoreFactory);
    }
    addAll(quads) {
        for (const quad of quads) {
            this.add(quad);
        }
        return this;
    }
    contains(other) {
        if (other.size > this.size) {
            return false;
        }
        for (const quad of other) {
            if (!this.has(quad)) {
                return false;
            }
        }
        return true;
    }
    deleteMatches(subject, predicate, object, graph) {
        const matching = this.match(subject, predicate, object, graph);
        for (const quad of matching) {
            this.dataset.delete(quad);
        }
        return this;
    }
    difference(other) {
        const dataset = this.createBlankDataset();
        for (const quad of this) {
            if (!other.has(quad)) {
                dataset.add(quad);
            }
        }
        return dataset;
    }
    equals(other) {
        if (this.size !== other.size) {
            return false;
        }
        for (const quad of this) {
            if (!other.has(quad)) {
                return false;
            }
        }
        return true;
    }
    every(iteratee) {
        for (const quad of this) {
            if (!iteratee(quad, this)) {
                return false;
            }
        }
        return true;
    }
    filter(iteratee) {
        const dataset = this.createBlankDataset();
        for (const quad of this) {
            if (iteratee(quad, this)) {
                dataset.add(quad);
            }
        }
        return dataset;
    }
    forEach(iteratee) {
        for (const quad of this) {
            iteratee(quad, this);
        }
    }
    import(stream) {
        return new Promise((resolve, reject) => {
            stream
                .on("data", (quad) => {
                this.add(quad);
            })
                .on("end", () => {
                resolve(this);
            })
                .on("error", (err) => reject(err));
        });
    }
    intersection(other) {
        const dataset = this.createBlankDataset();
        const iteratingDataset = this.size < other.size ? this : other;
        const comparingDataset = this.size < other.size ? other : this;
        for (const quad of iteratingDataset) {
            if (comparingDataset.has(quad)) {
                dataset.add(quad);
            }
        }
        return dataset;
    }
    map(iteratee) {
        const dataset = this.createBlankDataset();
        for (const quad of this) {
            dataset.add(iteratee(quad, this));
        }
        return dataset;
    }
    reduce(iteratee, initialValue) {
        if (this.size === 0 && initialValue == undefined) {
            throw new Error("Cannot reduce an empty Dataset without an initial value.");
        }
        const thisIterator = this[Symbol.iterator]();
        let iteratorResult = thisIterator.next();
        let accumulatedValue = initialValue;
        while (!iteratorResult.done) {
            accumulatedValue = iteratee(accumulatedValue, iteratorResult.value, this);
            iteratorResult = thisIterator.next();
        }
        return accumulatedValue;
    }
    some(iteratee) {
        for (const quad of this) {
            if (iteratee(quad, this)) {
                return true;
            }
        }
        return false;
    }
    toArray() {
        const array = [];
        for (const quad of this) {
            array.push(quad);
        }
        return array;
    }
    toCanonical() {
        throw new Error("Method not implemented.");
    }
    toStream() {
        const iterator = this[Symbol.iterator]();
        let curNext = iterator.next();
        const stream = new readable_stream_1.Readable({
            objectMode: true,
            read() {
                if (curNext.done || !curNext.value) {
                    this.push(null);
                    return;
                }
                this.push(curNext.value);
                curNext = iterator.next();
            },
        });
        return stream;
    }
    toString() {
        return (0, rdf_utils_1.datasetToString)(this, { format: "N-Triples" });
    }
    union(other) {
        const dataset = this.createBlankDataset();
        for (const quad of this) {
            dataset.add(quad);
        }
        for (const quad of other) {
            dataset.add(quad);
        }
        return dataset;
    }
    match(subject, predicate, object, graph) {
        return new ExtendedDataset(this.dataset.match(subject, predicate, object, graph), this.datasetCoreFactory);
    }
    get size() {
        return this.dataset.size;
    }
    add(quad) {
        this.dataset.add(quad);
        return this;
    }
    delete(quad) {
        this.dataset.delete(quad);
        return this;
    }
    has(quad) {
        return Boolean(this.dataset.has(quad));
    }
    [Symbol.iterator]() {
        return this.dataset[Symbol.iterator]();
    }
}
exports.default = ExtendedDataset;
//# sourceMappingURL=ExtendedDataset.js.map