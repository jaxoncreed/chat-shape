"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscribableDataset = void 0;
const events_1 = require("events");
const rdf_utils_1 = require("@ldo/rdf-utils");
const dataset_1 = require("@ldo/dataset");
class SubscribableDataset extends dataset_1.ExtendedDataset {
    constructor(datasetFactory, transactionDatasetFactory, initialDataset) {
        super(initialDataset || datasetFactory.dataset(), datasetFactory);
        this.listenerHashMap = new Map();
        this.transactionDatasetFactory = transactionDatasetFactory;
        this.eventEmitter = new events_1.EventEmitter();
        this.datasetFactory = datasetFactory;
    }
    superAddAll(quads) {
        for (const quad of quads) {
            super.add(quad);
        }
        return this;
    }
    addAll(quads) {
        this.superAddAll(quads);
        this.triggerSubscriptionForQuads({
            added: this.datasetFactory.dataset(quads),
        });
        return this;
    }
    bulk(changed) {
        if (changed.added) {
            this.superAddAll(changed.added);
        }
        if (changed.removed) {
            changed.removed.forEach((quad) => {
                super.delete(quad);
            });
        }
        this.triggerSubscriptionForQuads(changed);
        return this;
    }
    deleteMatches(subject, predicate, object, graph) {
        const matching = super.match(subject, predicate, object, graph);
        for (const quad of matching) {
            super.delete(quad);
        }
        this.triggerSubscriptionForQuads({ removed: matching });
        return this;
    }
    add(quad) {
        super.add(quad);
        this.triggerSubscriptionForQuads({
            added: this.datasetFactory.dataset([quad]),
        });
        return this;
    }
    delete(quad) {
        super.delete(quad);
        this.triggerSubscriptionForQuads({
            removed: this.datasetFactory.dataset([quad]),
        });
        return this;
    }
    triggerSubscriptionForQuads(changed) {
        const matchingDatasetChanges = {};
        const populateMatchingDatasetChanges = (changeType) => {
            const changedQuads = changed[changeType];
            changedQuads?.forEach((changedQuad) => {
                const quad = changedQuad;
                const quadMatches = [
                    [null, null, null, null],
                    [quad.subject, null, null, null],
                    [quad.subject, quad.predicate, null, null],
                    [quad.subject, null, quad.object, null],
                    [null, quad.predicate, null, null],
                    [null, quad.predicate, quad.object, null],
                    [null, null, quad.object, null],
                    [quad.subject, quad.predicate, quad.object, null],
                    [null, null, null, quad.graph],
                    [quad.subject, null, null, quad.graph],
                    [quad.subject, quad.predicate, null, quad.graph],
                    [quad.subject, null, quad.object, quad.graph],
                    [null, quad.predicate, null, quad.graph],
                    [null, quad.predicate, quad.object, quad.graph],
                    [null, null, quad.object, quad.graph],
                    [quad.subject, quad.predicate, quad.object, quad.graph],
                ];
                quadMatches.forEach((quadMatch) => {
                    const eventName = (0, rdf_utils_1.quadMatchToString)(quadMatch);
                    if (this.eventEmitter.listenerCount(eventName) > 0) {
                        if (!matchingDatasetChanges[eventName]) {
                            matchingDatasetChanges[eventName] = {};
                        }
                        if (!matchingDatasetChanges[eventName][changeType]) {
                            matchingDatasetChanges[eventName][changeType] =
                                this.datasetFactory.dataset();
                        }
                        matchingDatasetChanges[eventName][changeType]?.add(changedQuad);
                    }
                });
            });
        };
        populateMatchingDatasetChanges("added");
        populateMatchingDatasetChanges("removed");
        Object.entries(matchingDatasetChanges).forEach(([quadMatchString, changes]) => {
            this.eventEmitter.emit(quadMatchString, changes);
        });
    }
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    emit(eventName, changes) {
        return this.eventEmitter.emit((0, rdf_utils_1.quadMatchToString)(eventName), changes);
    }
    eventNames() {
        return this.eventEmitter
            .eventNames()
            .map((eventName) => (0, rdf_utils_1.stringToQuadMatch)(eventName));
    }
    getMaxListeners() {
        return this.eventEmitter.getMaxListeners();
    }
    listenerCount(eventName) {
        return this.eventEmitter.listenerCount((0, rdf_utils_1.quadMatchToString)(eventName));
    }
    listeners(eventName) {
        return this.eventEmitter.listeners((0, rdf_utils_1.quadMatchToString)(eventName));
    }
    off(eventName, listener) {
        this.removeListener(eventName, listener);
    }
    on(eventName, listener) {
        const eventString = (0, rdf_utils_1.quadMatchToString)(eventName);
        if (!this.listenerHashMap.has(listener)) {
            this.listenerHashMap.set(listener, new Set());
        }
        this.listenerHashMap.get(listener)?.add(eventString);
        this.eventEmitter.on(eventString, listener);
        return this;
    }
    once(eventName, listener) {
        this.eventEmitter.once((0, rdf_utils_1.quadMatchToString)(eventName), listener);
        return this;
    }
    prependListener(eventName, listener) {
        this.eventEmitter.prependListener((0, rdf_utils_1.quadMatchToString)(eventName), listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        this.eventEmitter.prependOnceListener((0, rdf_utils_1.quadMatchToString)(eventName), listener);
        return this;
    }
    removeAllListeners(eventName) {
        this.eventEmitter.removeAllListeners((0, rdf_utils_1.quadMatchToString)(eventName));
        return this;
    }
    removeListener(eventName, listener) {
        this.eventEmitter.removeListener((0, rdf_utils_1.quadMatchToString)(eventName), listener);
        return this;
    }
    removeListenerFromAllEvents(listener) {
        const eventStringSet = this.listenerHashMap.get(listener);
        if (eventStringSet) {
            eventStringSet.forEach((eventString) => {
                this.eventEmitter.off(eventString, listener);
            });
        }
        return this;
    }
    setMaxListeners(n) {
        this.eventEmitter.setMaxListeners(n);
        return this;
    }
    rawListeners(eventName) {
        return this.eventEmitter.rawListeners((0, rdf_utils_1.quadMatchToString)(eventName));
    }
    startTransaction() {
        return this.transactionDatasetFactory.transactionDataset(this);
    }
}
exports.SubscribableDataset = SubscribableDataset;
//# sourceMappingURL=SubscribableDataset.js.map