"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addObjectToDataset = exports.addRawObjectToDatasetRecursive = exports.addRawValueToDatasetRecursive = void 0;
const data_model_1 = require("@rdfjs/data-model");
const getNodeFromRaw_1 = require("./getNodeFromRaw");
const isSubjectProxy_1 = require("../subjectProxy/isSubjectProxy");
const NodeSet_1 = require("./NodeSet");
const languageUtils_1 = require("../language/languageUtils");
function addRawValueToDatasetRecursive(subject, key, value, visitedObjects, shouldDeleteOldTriples, proxyContext) {
    const { dataset, contextUtil } = proxyContext;
    const rdfType = proxyContext.getRdfType(subject);
    const predicate = (0, data_model_1.namedNode)(contextUtil.keyToIri(key, rdfType));
    const object = (0, getNodeFromRaw_1.getNodeFromRawValue)(key, value, rdfType, proxyContext);
    if (object == undefined) {
        dataset.deleteMatches(subject, predicate);
    }
    else if (object.termType === "Literal") {
        let languageAppliedObject = object;
        if (contextUtil.isLangString(key, rdfType)) {
            const languageKey = (0, languageUtils_1.getLanguageKeyForWriteOperation)(proxyContext.languageOrdering);
            if (!languageKey)
                return;
            languageAppliedObject = (0, data_model_1.literal)(object.value, (0, languageUtils_1.languageKeyToLiteralLanguage)(languageKey));
        }
        proxyContext.writeGraphs.forEach((graph) => {
            proxyContext.dataset.add((0, data_model_1.quad)(subject, predicate, languageAppliedObject, graph));
        });
    }
    else {
        proxyContext.writeGraphs.forEach((graph) => {
            dataset.add((0, data_model_1.quad)(subject, predicate, object, graph));
        });
        if (!(0, isSubjectProxy_1.isSubjectProxy)(value)) {
            const updateData = (typeof value === "object"
                ? { ...value, "@id": object }
                : { "@id": object });
            addRawObjectToDatasetRecursive(updateData, visitedObjects, shouldDeleteOldTriples, proxyContext);
        }
    }
}
exports.addRawValueToDatasetRecursive = addRawValueToDatasetRecursive;
function addRawObjectToDatasetRecursive(item, visitedObjects, shouldDeleteOldTriples, proxyContext) {
    if ((0, isSubjectProxy_1.isSubjectProxy)(item)) {
        return item;
    }
    const { dataset } = proxyContext;
    const subject = (0, getNodeFromRaw_1.getNodeFromRawObject)(item, proxyContext.contextUtil);
    const rdfType = proxyContext.getRdfType(subject);
    if (visitedObjects.has(subject)) {
        return proxyContext.createSubjectProxy(subject);
    }
    visitedObjects.add(subject);
    Object.entries(item).forEach(([key, value]) => {
        if (key === "@id") {
            return;
        }
        const predicate = (0, data_model_1.namedNode)(proxyContext.contextUtil.keyToIri(key, rdfType));
        if (shouldDeleteOldTriples) {
            if (proxyContext.contextUtil.isLangString(key, rdfType)) {
                const languageKey = (0, languageUtils_1.getLanguageKeyForWriteOperation)(proxyContext.languageOrdering);
                if (languageKey) {
                    (0, languageUtils_1.languageDeleteMatch)(dataset, subject, predicate, languageKey);
                }
            }
            else {
                dataset.deleteMatches(subject, predicate);
            }
        }
        if (Array.isArray(value)) {
            value.forEach((valueItem) => {
                addRawValueToDatasetRecursive(subject, key, valueItem, visitedObjects, true, proxyContext);
            });
        }
        else {
            addRawValueToDatasetRecursive(subject, key, value, visitedObjects, true, proxyContext);
        }
    });
    return proxyContext.createSubjectProxy(subject);
}
exports.addRawObjectToDatasetRecursive = addRawObjectToDatasetRecursive;
function addObjectToDataset(item, shouldDeleteOldTriples, proxyContext) {
    return addRawObjectToDatasetRecursive(item, new NodeSet_1.NodeSet(), shouldDeleteOldTriples, proxyContext);
}
exports.addObjectToDataset = addObjectToDataset;
//# sourceMappingURL=addObjectToDataset.js.map