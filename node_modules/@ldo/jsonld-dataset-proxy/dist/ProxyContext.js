"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyContext = void 0;
const createArrayHandler_1 = require("./arrayProxy/createArrayHandler");
const createSubjectHandler_1 = require("./subjectProxy/createSubjectHandler");
const types_1 = require("./types");
const data_model_1 = require("@rdfjs/data-model");
const rdfType = (0, data_model_1.namedNode)("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
class ProxyContext {
    constructor(options) {
        this.subjectMap = new Map();
        this.arrayMap = new Map();
        this.dataset = options.dataset;
        this.contextUtil = options.contextUtil;
        this.writeGraphs = options.writeGraphs;
        this.languageOrdering = options.languageOrdering;
        this.state = options.state || {};
        if (options.prefilledArrayTargets) {
            options.prefilledArrayTargets.forEach((target) => {
                this.createArrayProxy(target[0], target[2], target);
            });
        }
    }
    createSubjectProxy(node) {
        if (!this.subjectMap.has(node.value)) {
            const proxy = new Proxy({ "@id": node }, this.createSubjectHandler());
            this.subjectMap.set(node.value, proxy);
        }
        return this.subjectMap.get(node.value);
    }
    createSubjectHandler() {
        return (0, createSubjectHandler_1.createSubjectHandler)(this);
    }
    getArrayKey(...quadMatch) {
        return `${quadMatch[0]?.value || "undefined"}|${quadMatch[1]?.value || "undefined"}|${quadMatch[2]?.value || "undefined"}|${quadMatch[3]?.value || "undefined"}`;
    }
    createArrayProxy(quadMatch, isSubjectOriented = false, initialTarget, isLangStringArray) {
        const key = this.getArrayKey(...quadMatch);
        if (!this.arrayMap.has(key)) {
            const proxy = new Proxy(initialTarget || [quadMatch, [], isSubjectOriented, isLangStringArray], this.createArrayHandler());
            this.arrayMap.set(key, proxy);
        }
        return this.arrayMap.get(key);
    }
    createArrayHandler() {
        return (0, createArrayHandler_1.createArrayHandler)(this);
    }
    duplicate(alternativeOptions) {
        const prefilledArrayTargets = [];
        this.arrayMap.forEach((value) => {
            prefilledArrayTargets.push(value[types_1._getUnderlyingArrayTarget]);
        });
        const fullOptions = {
            ...{
                dataset: this.dataset,
                contextUtil: this.contextUtil,
                writeGraphs: this.writeGraphs,
                languageOrdering: this.languageOrdering,
                prefilledArrayTargets,
            },
            ...alternativeOptions,
        };
        return new ProxyContext(fullOptions);
    }
    getRdfType(subjectNode) {
        return this.dataset
            .match(subjectNode, rdfType)
            .toArray()
            .map((quad) => quad.object)
            .filter((object) => object.termType === "NamedNode");
    }
}
exports.ProxyContext = ProxyContext;
//# sourceMappingURL=ProxyContext.js.map