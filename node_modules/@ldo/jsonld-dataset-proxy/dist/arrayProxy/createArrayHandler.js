"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createArrayHandler = void 0;
const data_model_1 = require("@rdfjs/data-model");
const nodeToJsonldRepresentation_1 = require("../util/nodeToJsonldRepresentation");
const arrayMethods_1 = require("./arrayMethods");
const types_1 = require("../types");
const modifyArray_1 = require("./modifyArray");
const NodeSet_1 = require("../util/NodeSet");
const languageUtils_1 = require("../language/languageUtils");
function updateArrayOrder(target, proxyContext) {
    let quads = proxyContext.dataset.match(...target[0]);
    if (target[3]) {
        quads = (0, languageUtils_1.filterQuadsByLanguageOrdering)(quads, proxyContext.languageOrdering);
    }
    const datasetObjects = new NodeSet_1.NodeSet();
    quads.toArray().forEach((quad) => {
        if (target[2]) {
            datasetObjects.add(quad.subject);
        }
        else {
            datasetObjects.add(quad.object);
        }
    });
    const processedObjects = [];
    target[1].forEach((arrItem) => {
        if (datasetObjects.has(arrItem)) {
            processedObjects.push(arrItem);
            datasetObjects.delete(arrItem);
        }
    });
    datasetObjects.toArray().forEach((datasetObject) => {
        processedObjects.push(datasetObject);
    });
    target[1] = processedObjects;
}
function getProcessedArray(target, proxyContext) {
    return target[1].map((node) => {
        return (0, nodeToJsonldRepresentation_1.nodeToJsonldRepresentation)(node, proxyContext);
    });
}
function createArrayHandler(proxyContext) {
    return {
        get(target, key, ...rest) {
            switch (key) {
                case types_1._getUnderlyingDataset:
                    return proxyContext.dataset;
                case types_1._getUnderlyingMatch:
                    return target[0];
                case types_1._isSubjectOriented:
                    return target[2];
                case types_1._getUnderlyingArrayTarget:
                    return target;
                case types_1._proxyContext:
                    return proxyContext;
                case types_1._getNodeAtIndex:
                    return (index) => {
                        updateArrayOrder(target, proxyContext);
                        return target[1][index];
                    };
            }
            updateArrayOrder(target, proxyContext);
            const processedArray = getProcessedArray(target, proxyContext);
            if (arrayMethods_1.methodNames.has(key)) {
                return arrayMethods_1.arrayMethodsBuilders[key](target, key, proxyContext);
            }
            return Reflect.get(processedArray, key, ...rest);
        },
        getOwnPropertyDescriptor(target, key, ...rest) {
            updateArrayOrder(target, proxyContext);
            const processedArray = getProcessedArray(target, proxyContext);
            return Reflect.getOwnPropertyDescriptor(processedArray, key, ...rest);
        },
        ownKeys(target, ...rest) {
            updateArrayOrder(target, proxyContext);
            const processedArray = getProcessedArray(target, proxyContext);
            return Reflect.ownKeys(processedArray, ...rest);
        },
        getPrototypeOf(target, ...rest) {
            updateArrayOrder(target, proxyContext);
            const processedObjects = getProcessedArray(target, proxyContext);
            return Reflect.getPrototypeOf(processedObjects, ...rest);
        },
        has(target, ...rest) {
            updateArrayOrder(target, proxyContext);
            const processedObjects = getProcessedArray(target, proxyContext);
            return Reflect.has(processedObjects, ...rest);
        },
        set(target, key, value, ...rest) {
            if (key === types_1._proxyContext) {
                proxyContext = value;
                return true;
            }
            updateArrayOrder(target, proxyContext);
            if (typeof key !== "symbol" && !isNaN(parseInt(key))) {
                const index = parseInt(key);
                return (0, modifyArray_1.modifyArray)({
                    target,
                    key,
                    toAdd: [value],
                    quadsToDelete(allQuads) {
                        return allQuads[index] ? [allQuads[index]] : [];
                    },
                    modifyCoreArray(coreArray, addedValues) {
                        coreArray[index] = addedValues[0];
                        return true;
                    },
                }, proxyContext);
            }
            return Reflect.set(target[1], key, ...rest);
        },
        deleteProperty(target, key) {
            const { dataset } = proxyContext;
            if (typeof key !== "symbol" && !isNaN(parseInt(key))) {
                const objectQuad = dataset.match(...target[0]).toArray()[parseInt(key)];
                if (!objectQuad) {
                    return true;
                }
                const term = target[2] ? objectQuad.subject : objectQuad.object;
                if (term.termType === "Literal") {
                    const subject = target[0][0];
                    const predicate = target[0][1];
                    if (subject && predicate) {
                        dataset.delete((0, data_model_1.quad)(subject, predicate, term));
                    }
                    return true;
                }
                else if (term.termType === "NamedNode" ||
                    term.termType === "BlankNode") {
                    dataset.deleteMatches(term, undefined, undefined);
                    dataset.deleteMatches(undefined, undefined, term);
                    return true;
                }
            }
            return true;
        },
    };
}
exports.createArrayHandler = createArrayHandler;
//# sourceMappingURL=createArrayHandler.js.map