"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyArray = exports.checkArrayModification = void 0;
const data_model_1 = require("@rdfjs/data-model");
const subscribable_dataset_1 = require("@ldo/subscribable-dataset");
const dataset_1 = require("@ldo/dataset");
const addObjectToDataset_1 = require("../util/addObjectToDataset");
const getNodeFromRaw_1 = require("../util/getNodeFromRaw");
const NodeSet_1 = require("../util/NodeSet");
function checkArrayModification(target, objectsToAdd, proxyContext) {
    if (target[2]) {
        for (const objectToAdd of objectsToAdd) {
            if (objectToAdd === undefined) {
                return;
            }
            if (typeof objectToAdd !== "object") {
                throw new Error(`Cannot add a literal "${objectToAdd}"(${typeof objectToAdd}) to a subject-oriented collection.`);
            }
            const testDataset = new subscribable_dataset_1.TransactionDataset(proxyContext.dataset, (0, dataset_1.createDatasetFactory)(), (0, subscribable_dataset_1.createTransactionDatasetFactory)());
            (0, addObjectToDataset_1.addObjectToDataset)(objectToAdd, false, proxyContext.duplicate({
                writeGraphs: [(0, data_model_1.defaultGraph)()],
            }));
            const isValidAddition = testDataset.match((0, getNodeFromRaw_1.getNodeFromRawObject)(objectToAdd, proxyContext.contextUtil), target[0][1], target[0][2]).size !== 0;
            if (!isValidAddition) {
                throw new Error(`Cannot add value to collection. This must contain a quad that matches (${(0, NodeSet_1.nodeToString)(target[0][0])}, ${(0, NodeSet_1.nodeToString)(target[0][1])}, ${(0, NodeSet_1.nodeToString)(target[0][2])}, ${(0, NodeSet_1.nodeToString)(target[0][3])})`);
            }
        }
    }
    else if (!target[0][0] || !target[0][1]) {
        throw new Error("A collection that does not specify a match for both a subject or predicate cannot be modified directly.");
    }
}
exports.checkArrayModification = checkArrayModification;
function modifyArray(config, proxyContext) {
    const { target, toAdd, quadsToDelete, modifyCoreArray, key } = config;
    const { dataset, contextUtil } = proxyContext;
    checkArrayModification(target, toAdd || [], proxyContext);
    if (quadsToDelete) {
        const quadArr = dataset.match(...target[0]).toArray();
        const deleteQuadArr = quadsToDelete(quadArr);
        deleteQuadArr.forEach((delQuad) => {
            if (target[2]) {
                dataset.deleteMatches(delQuad.subject, undefined, undefined);
            }
            else {
                dataset.delete(delQuad);
            }
        });
    }
    const added = toAdd
        ?.map((item) => {
        return typeof item === "object"
            ? (0, addObjectToDataset_1.addObjectToDataset)(item, false, proxyContext)
            : item;
    })
        .filter((val) => val != undefined);
    if (!target[2] && target[0][0] && target[0][1] && added) {
        (0, addObjectToDataset_1.addObjectToDataset)({
            "@id": target[0][0],
            [contextUtil.iriToKey(target[0][1].value, proxyContext.getRdfType(target[0][0]))]: added,
        }, false, proxyContext);
    }
    const addedNodes = added
        ? added
            .map((addedValue) => {
            return (0, getNodeFromRaw_1.getNodeFromRawValue)(key, addedValue, target[0][0] ? proxyContext.getRdfType(target[0][0]) : [], proxyContext);
        })
            .filter((val) => val != undefined)
        : [];
    return modifyCoreArray(target[1], addedNodes);
}
exports.modifyArray = modifyArray;
//# sourceMappingURL=modifyArray.js.map