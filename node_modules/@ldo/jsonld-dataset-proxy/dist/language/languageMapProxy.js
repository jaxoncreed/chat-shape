"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageMapProxy = void 0;
const data_model_1 = require("@rdfjs/data-model");
const languageUtils_1 = require("./languageUtils");
const languageSet_1 = __importDefault(require("./languageSet"));
function createLanguageMapProxy(subject, predicate, proxyContext, isArray) {
    const target = {};
    const targetSetter = (target) => {
        Object.keys(target).forEach((key) => delete target[key]);
        const allQuads = proxyContext.dataset.match(subject, predicate);
        const languageQuadMap = (0, languageUtils_1.quadsToLanguageQuadMap)(allQuads);
        Object.entries(languageQuadMap).forEach(([language, quads]) => {
            const stringArray = quads.toArray().map((quad) => quad.object.value);
            if (isArray) {
                target[language] = new Set(stringArray);
            }
            else {
                target[language] = stringArray[0];
            }
        });
    };
    targetSetter(target);
    return new Proxy(target, {
        get: (target, key) => {
            targetSetter(target);
            if (typeof key !== "string") {
                return Reflect.get(target, key);
            }
            if (isArray) {
                return new languageSet_1.default(subject, predicate, key, proxyContext);
            }
            return Reflect.get(target, key);
        },
        set: (target, key, value) => {
            const language = (0, languageUtils_1.languageKeyToLiteralLanguage)(key);
            if (!isArray) {
                (0, languageUtils_1.languageDeleteMatch)(proxyContext.dataset, subject, predicate, language);
            }
            proxyContext.writeGraphs.forEach((writeGraph) => {
                proxyContext.dataset.add((0, data_model_1.quad)(subject, predicate, (0, data_model_1.literal)(value, language), writeGraph));
            });
            return Reflect.set(target, key, value);
        },
        deleteProperty: (target, key) => {
            (0, languageUtils_1.languageDeleteMatch)(proxyContext.dataset, subject, predicate, (0, languageUtils_1.languageKeyToLiteralLanguage)(key));
            return Reflect.deleteProperty(target, key);
        },
    });
}
exports.createLanguageMapProxy = createLanguageMapProxy;
//# sourceMappingURL=languageMapProxy.js.map