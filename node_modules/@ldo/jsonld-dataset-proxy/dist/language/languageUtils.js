"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.literalLanguageToLanguageKey = exports.languageKeyToLiteralLanguage = exports.getLanguageKeyForWriteOperation = exports.filterQuadsByLanguageOrdering = exports.quadsToLanguageQuadMap = exports.isLanguageLiteral = exports.languageDeleteMatch = exports.languageMatch = void 0;
const dataset_1 = require("@ldo/dataset");
function languageMatch(dataset, subject, predicate, languageKey) {
    const literalLanguage = languageKeyToLiteralLanguage(languageKey);
    return dataset.match(subject, predicate).filter((quad) => {
        return (isLanguageLiteral(quad.object) && quad.object.language === literalLanguage);
    });
}
exports.languageMatch = languageMatch;
function languageDeleteMatch(dataset, subject, predicate, languageKey) {
    const quadsToDelete = languageMatch(dataset, subject, predicate, languageKey);
    quadsToDelete.forEach((quad) => {
        dataset.delete(quad);
    });
}
exports.languageDeleteMatch = languageDeleteMatch;
function isLanguageLiteral(node) {
    return (node.termType === "Literal" &&
        (node.datatype.value ===
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ||
            node.datatype.value === "http://www.w3.org/2001/XMLSchema#string"));
}
exports.isLanguageLiteral = isLanguageLiteral;
function quadsToLanguageQuadMap(quads) {
    const languageQuadMap = {};
    quads.forEach((quad) => {
        const literal = quad.object;
        if (isLanguageLiteral(literal)) {
            const languageKey = literalLanguageToLanguageKey(literal.language);
            if (!languageQuadMap[languageKey]) {
                languageQuadMap[languageKey] =
                    (0, dataset_1.createDataset)();
            }
            languageQuadMap[languageKey].add(quad);
        }
    });
    return languageQuadMap;
}
exports.quadsToLanguageQuadMap = quadsToLanguageQuadMap;
function filterQuadsByLanguageOrdering(quads, languageOrdering) {
    const languageQuadMap = quadsToLanguageQuadMap(quads);
    const validLanguages = new Set(languageOrdering);
    const presentLanguages = new Set(Object.keys(languageQuadMap));
    for (const currentLanguageKey of languageOrdering) {
        if (presentLanguages.has(currentLanguageKey)) {
            return languageQuadMap[currentLanguageKey];
        }
        if (currentLanguageKey === "@other") {
            for (const presentLang of presentLanguages) {
                if (!validLanguages.has(presentLang)) {
                    return languageQuadMap[presentLang];
                }
            }
        }
    }
    return (0, dataset_1.createDataset)();
}
exports.filterQuadsByLanguageOrdering = filterQuadsByLanguageOrdering;
function getLanguageKeyForWriteOperation(languageOrdering) {
    return languageOrdering.find((lang) => lang !== "@other");
}
exports.getLanguageKeyForWriteOperation = getLanguageKeyForWriteOperation;
function languageKeyToLiteralLanguage(languageKey) {
    return (languageKey === "@none" ? "" : languageKey);
}
exports.languageKeyToLiteralLanguage = languageKeyToLiteralLanguage;
function literalLanguageToLanguageKey(literalLanguage) {
    return literalLanguage === "" ? "@none" : literalLanguage;
}
exports.literalLanguageToLanguageKey = literalLanguageToLanguageKey;
//# sourceMappingURL=languageUtils.js.map