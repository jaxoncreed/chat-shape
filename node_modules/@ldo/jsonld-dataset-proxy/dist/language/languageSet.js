"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const data_model_1 = require("@rdfjs/data-model");
const languageUtils_1 = require("./languageUtils");
class LanguageSet {
    constructor(subject, predicate, languageKey, proxyContext) {
        this[_a] = "LanguageSet";
        this.subject = subject;
        this.predicate = predicate;
        this.languageKey = languageKey;
        this.proxyContext = proxyContext;
    }
    matchThis() {
        return (0, languageUtils_1.languageMatch)(this.proxyContext.dataset, this.subject, this.predicate, this.languageKey);
    }
    getLiteral(value) {
        return this.languageKey === "@none"
            ? (0, data_model_1.literal)(value)
            : (0, data_model_1.literal)(value, this.languageKey);
    }
    get size() {
        return this.matchThis().size;
    }
    add(value) {
        this.proxyContext.writeGraphs.forEach((graph) => {
            this.proxyContext.dataset.add((0, data_model_1.quad)(this.subject, this.predicate, (0, data_model_1.literal)(value, this.languageKey), graph));
        });
        return this;
    }
    clear() {
        (0, languageUtils_1.languageDeleteMatch)(this.proxyContext.dataset, this.subject, this.predicate, this.languageKey);
    }
    delete(value) {
        const hadValue = this.has(value);
        this.proxyContext.dataset.deleteMatches(this.subject, this.predicate, this.getLiteral(value));
        return hadValue;
    }
    forEach(callbackfn, thisArg) {
        const quads = this.matchThis();
        quads.forEach((curQuad) => {
            callbackfn(curQuad.object.value, curQuad.object.value, thisArg || this);
        });
    }
    has(item) {
        return (this.proxyContext.dataset.match(this.subject, this.predicate, this.getLiteral(item)).size > 0);
    }
    *entries() {
        const quads = this.matchThis();
        for (const curQuad of quads) {
            yield [curQuad.object.value, curQuad.object.value];
        }
    }
    *keys() {
        const quads = this.matchThis();
        for (const curQuad of quads) {
            yield curQuad.object.value;
        }
    }
    *values() {
        const quads = this.matchThis();
        for (const curQuad of quads) {
            yield curQuad.object.value;
        }
    }
    *[Symbol.iterator]() {
        const quads = this.matchThis();
        for (const curQuad of quads) {
            yield curQuad.object.value;
        }
    }
}
exports.default = LanguageSet;
_a = Symbol.toStringTag;
//# sourceMappingURL=languageSet.js.map