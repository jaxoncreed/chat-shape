"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShexJNameVisitor = void 0;
const traverser_shexj_1 = __importDefault(require("@ldo/traverser-shexj"));
const getRdfTypesForTripleConstraint_1 = require("../util/getRdfTypesForTripleConstraint");
exports.ShexJNameVisitor = traverser_shexj_1.default.createVisitor({
    Shape: {
        visitor: async (_shape, _context) => { },
    },
    TripleConstraint: {
        visitor: async (tripleConstraint, node, context) => {
            const rdfTypes = (0, getRdfTypesForTripleConstraint_1.getRdfTypesForTripleConstraint)(node);
            rdfTypes.forEach((rdfType) => {
                if (tripleConstraint.valueExpr) {
                    const isContainer = tripleConstraint.max !== undefined && tripleConstraint.max !== 1;
                    if (typeof tripleConstraint.valueExpr === "string") {
                    }
                    else if (tripleConstraint.valueExpr.type === "NodeConstraint") {
                        if (tripleConstraint.valueExpr.datatype) {
                            context.addPredicate(tripleConstraint.predicate, {
                                "@type": tripleConstraint.valueExpr.datatype,
                            }, isContainer, rdfType, tripleConstraint.annotations);
                        }
                        else if (tripleConstraint.valueExpr.nodeKind &&
                            tripleConstraint.valueExpr.nodeKind !== "literal") {
                            context.addPredicate(tripleConstraint.predicate, { "@type": "@id" }, isContainer, rdfType, tripleConstraint.annotations);
                        }
                        else {
                            context.addPredicate(tripleConstraint.predicate, {}, isContainer, rdfType, tripleConstraint.annotations);
                        }
                    }
                    else {
                        context.addPredicate(tripleConstraint.predicate, {
                            "@type": "@id",
                        }, isContainer, rdfType, tripleConstraint.annotations);
                    }
                }
                else {
                    context.addSubject(tripleConstraint.predicate, rdfType, tripleConstraint.annotations);
                }
            });
        },
    },
    NodeConstraint: {
        visitor: async (nodeConstraint, node, context) => {
            if (nodeConstraint.values) {
                nodeConstraint.values.forEach((value) => {
                    if (typeof value === "string") {
                        context.addSubject(value);
                    }
                });
            }
        },
    },
    IriStem: {
        visitor: async (iriStem, node, context) => {
            context.addSubject(iriStem.stem);
        },
    },
});
//# sourceMappingURL=ShexJContextVisitor.js.map