"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShexJTypingTransformer = exports.commentFromAnnotations = void 0;
const traverser_shexj_1 = __importDefault(require("@ldo/traverser-shexj"));
const dom = __importStar(require("dts-dom"));
const JsonLdContextBuilder_1 = require("../context/JsonLdContextBuilder");
const getRdfTypesForTripleConstraint_1 = require("../util/getRdfTypesForTripleConstraint");
const dedupeObjectTypeMembers_1 = require("./util/dedupeObjectTypeMembers");
function commentFromAnnotations(annotations) {
    const commentAnnotationObject = annotations?.find((annotation) => annotation.predicate === "http://www.w3.org/2000/01/rdf-schema#comment")?.object;
    if (typeof commentAnnotationObject === "string") {
        return commentAnnotationObject;
    }
    else {
        return commentAnnotationObject?.value;
    }
}
exports.commentFromAnnotations = commentFromAnnotations;
exports.ShexJTypingTransformer = traverser_shexj_1.default.createTransformer({
    Schema: {
        transformer: async (_schema, getTransformedChildren) => {
            const transformedChildren = await getTransformedChildren();
            const interfaces = [];
            transformedChildren.shapes?.forEach((shape) => {
                if (typeof shape !== "string" &&
                    shape.kind === "interface") {
                    interfaces.push(shape);
                }
            });
            return interfaces;
        },
    },
    ShapeDecl: {
        transformer: async (shapeDecl, getTransformedChildren) => {
            const shapeName = (0, JsonLdContextBuilder_1.nameFromObject)(shapeDecl) || "Shape";
            const { shapeExpr } = await getTransformedChildren();
            if (shapeExpr.kind === "interface") {
                const shapeInterface = shapeExpr;
                shapeInterface.name = shapeName;
                shapeInterface.shapeId = shapeDecl.id;
                return shapeInterface;
            }
            else {
                throw new Error("Cannot handle ShapeOr, ShapeAnd, ShapeNot, ShapeExternal, or NodeConstraint direcly on ShapeDecl.");
            }
        },
    },
    Shape: {
        transformer: async (shape, getTransformedChildren, setReturnPointer) => {
            const newInterface = dom.create.interface("");
            setReturnPointer(newInterface);
            const transformedChildren = await getTransformedChildren();
            newInterface.members.push(dom.create.property("@id", dom.type.string, dom.DeclarationFlags.Optional));
            newInterface.members.push(dom.create.property("@context", dom.create.namedTypeReference("ContextDefinition"), dom.DeclarationFlags.Optional));
            if (typeof transformedChildren.expression === "string") {
            }
            else if (transformedChildren.expression.kind === "object" ||
                transformedChildren.expression.kind ===
                    "interface") {
                newInterface.members.push(...transformedChildren.expression.members);
            }
            else if (transformedChildren.expression.kind ===
                "property") {
                newInterface.members.push(transformedChildren.expression);
            }
            if (transformedChildren.extends) {
                transformedChildren.extends.forEach((extendsItem) => {
                    const extendsInterface = extendsItem;
                    if (extendsInterface.kind === "interface") {
                        newInterface.members = (0, dedupeObjectTypeMembers_1.dedupeObjectTypeMembers)([
                            ...extendsInterface.members,
                            ...newInterface.members,
                        ]);
                    }
                });
            }
            return newInterface;
        },
    },
    EachOf: {
        transformer: async (eachOf, getTransformedChildren, setReturnPointer) => {
            const transformedChildren = await getTransformedChildren();
            const name = (0, JsonLdContextBuilder_1.nameFromObject)(eachOf);
            const objectType = name
                ? dom.create.interface(name)
                : dom.create.objectType([]);
            setReturnPointer(objectType);
            const inputPropertyExpressions = [];
            transformedChildren.expressions
                .filter((expression) => {
                return (expression.kind === "property" ||
                    expression.kind === "object" ||
                    expression.kind === "interface");
            })
                .forEach((expression) => {
                if (expression.kind === "property") {
                    inputPropertyExpressions.push(expression);
                }
                else {
                    expression.members.forEach((objectMember) => {
                        if (objectMember.kind === "property") {
                            inputPropertyExpressions.push(objectMember);
                        }
                    });
                }
            });
            objectType.members.push(...(0, dedupeObjectTypeMembers_1.dedupeObjectTypeMembers)(inputPropertyExpressions));
            return objectType;
        },
    },
    TripleConstraint: {
        transformer: async (tripleConstraint, getTransformedChildren, setReturnPointer, node, context) => {
            const transformedChildren = await getTransformedChildren();
            const rdfTypes = (0, getRdfTypesForTripleConstraint_1.getRdfTypesForTripleConstraint)(node);
            const propertyName = context.getNameFromIri(tripleConstraint.predicate, rdfTypes[0]);
            const isArray = tripleConstraint.max !== undefined && tripleConstraint.max !== 1;
            const isOptional = tripleConstraint.min === 0;
            let type = dom.type.any;
            if (transformedChildren.valueExpr) {
                type = transformedChildren.valueExpr;
            }
            const propertyDeclaration = dom.create.property(propertyName, isArray ? dom.type.array(type) : type, isOptional ? dom.DeclarationFlags.Optional : dom.DeclarationFlags.None);
            propertyDeclaration.jsDocComment = commentFromAnnotations(tripleConstraint.annotations);
            return propertyDeclaration;
        },
    },
    NodeConstraint: {
        transformer: async (nodeConstraint, _getTransformedChildren, setReturnPointer, node, context) => {
            if (nodeConstraint.datatype) {
                switch (nodeConstraint.datatype) {
                    case "http://www.w3.org/2001/XMLSchema#string":
                    case "http://www.w3.org/2001/XMLSchema#ENTITIES":
                    case "http://www.w3.org/2001/XMLSchema#ENTITY":
                    case "http://www.w3.org/2001/XMLSchema#ID":
                    case "http://www.w3.org/2001/XMLSchema#IDREF":
                    case "http://www.w3.org/2001/XMLSchema#IDREFS":
                    case "http://www.w3.org/2001/XMLSchema#language":
                    case "http://www.w3.org/2001/XMLSchema#Name":
                    case "http://www.w3.org/2001/XMLSchema#NCName":
                    case "http://www.w3.org/2001/XMLSchema#NMTOKEN":
                    case "http://www.w3.org/2001/XMLSchema#NMTOKENS":
                    case "http://www.w3.org/2001/XMLSchema#normalizedString":
                    case "http://www.w3.org/2001/XMLSchema#QName":
                    case "http://www.w3.org/2001/XMLSchema#token":
                        return dom.type.string;
                    case "http://www.w3.org/2001/XMLSchema#date":
                    case "http://www.w3.org/2001/XMLSchema#dateTime":
                    case "http://www.w3.org/2001/XMLSchema#duration":
                    case "http://www.w3.org/2001/XMLSchema#gDay":
                    case "http://www.w3.org/2001/XMLSchema#gMonth":
                    case "http://www.w3.org/2001/XMLSchema#gMonthDay":
                    case "http://www.w3.org/2001/XMLSchema#gYear":
                    case "http://www.w3.org/2001/XMLSchema#gYearMonth":
                    case "http://www.w3.org/2001/XMLSchema#time":
                        return dom.type.string;
                    case "http://www.w3.org/2001/XMLSchema#byte":
                    case "http://www.w3.org/2001/XMLSchema#decimal":
                    case "http://www.w3.org/2001/XMLSchema#int":
                    case "http://www.w3.org/2001/XMLSchema#integer":
                    case "http://www.w3.org/2001/XMLSchema#long":
                    case "http://www.w3.org/2001/XMLSchema#negativeInteger":
                    case "http://www.w3.org/2001/XMLSchema#nonNegativeInteger":
                    case "http://www.w3.org/2001/XMLSchema#nonPositiveInteger":
                    case "http://www.w3.org/2001/XMLSchema#positiveInteger":
                    case "http://www.w3.org/2001/XMLSchema#short":
                    case "http://www.w3.org/2001/XMLSchema#unsignedLong":
                    case "http://www.w3.org/2001/XMLSchema#unsignedInt":
                    case "http://www.w3.org/2001/XMLSchema#unsignedShort":
                    case "http://www.w3.org/2001/XMLSchema#unsignedByte":
                        return dom.type.number;
                    case "http://www.w3.org/2001/XMLSchema#boolean":
                        return dom.type.boolean;
                    case "http://www.w3.org/2001/XMLSchema#hexBinary":
                        return dom.type.string;
                    case "http://www.w3.org/2001/XMLSchema#anyURI":
                        return dom.type.string;
                    default:
                        return dom.type.string;
                }
            }
            if (nodeConstraint.nodeKind) {
                switch (nodeConstraint.nodeKind) {
                    case "iri":
                        return dom.create.objectType([
                            dom.create.property("@id", dom.type.string),
                        ]);
                    case "bnode":
                        return dom.create.objectType([]);
                    case "nonliteral":
                        return dom.create.objectType([
                            dom.create.property("@id", dom.type.string, dom.DeclarationFlags.Optional),
                        ]);
                    case "literal":
                    default:
                        return dom.type.string;
                }
            }
            if (nodeConstraint.values) {
                const valuesUnion = dom.create.union([]);
                nodeConstraint.values.forEach((value) => {
                    if (typeof value === "string") {
                        valuesUnion.members.push(dom.create.objectType([
                            dom.create.property("@id", dom.type.stringLiteral(context.getNameFromIri(value))),
                        ]));
                    }
                });
                return valuesUnion;
            }
            return dom.type.undefined;
        },
    },
    ShapeOr: {
        transformer: async (shapeOr, getTransformedChildren) => {
            const transformedChildren = await getTransformedChildren();
            const validTypes = [];
            transformedChildren.shapeExprs.forEach((type) => {
                if (typeof type === "object")
                    validTypes.push(type);
            });
            return dom.create.union(validTypes);
        },
    },
    ShapeAnd: {
        transformer: async (shapeAnd, getTransformedChildren) => {
            const transformedChildren = await getTransformedChildren();
            const validTypes = [];
            transformedChildren.shapeExprs.forEach((type) => {
                if (typeof type === "object")
                    validTypes.push(type);
            });
            return dom.create.intersection(validTypes);
        },
    },
    ShapeNot: {
        transformer: async () => {
            throw new Error("ShapeNot is not supported");
        },
    },
    ShapeExternal: {
        transformer: async () => {
            throw new Error("ShapeExternal is not supported");
        },
    },
});
//# sourceMappingURL=ShexJTypingTransformer.js.map