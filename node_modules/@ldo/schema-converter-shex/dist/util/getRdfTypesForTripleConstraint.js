"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRdfTypesForTripleConstraint = void 0;
function recursivelyGatherTypesFromShapeNodes(shapeNode, rdfTypeSet) {
    shapeNode.parent("shapeExpr").forEach((parentShapeExpr) => {
        parentShapeExpr
            .parent("ShapeDecl", "shapeExpr")
            .forEach((parentShapeDecl) => {
            parentShapeDecl
                .parent("shapeDeclRef")
                .forEach((parentShapeDeclOrRef) => {
                parentShapeDeclOrRef
                    .parent("shapeExprOrRef")
                    .forEach((parentShapeExprOrRef) => {
                    parentShapeExprOrRef
                        .parent("Shape", "extends")
                        .forEach((parentShape) => {
                        recursivelyGatherTypesFromShapeNodes(parentShape, rdfTypeSet);
                        const childExpressionNode = parentShape.child("expression");
                        if (!childExpressionNode)
                            return;
                        const childEachOf = childExpressionNode.child().child();
                        if (childEachOf.typeName === "EachOf") {
                            recursivelyGatherTypesFromEachOfNodes(childEachOf, rdfTypeSet);
                        }
                    });
                });
            });
        });
    });
}
function recursivelyGatherTypesFromEachOfNodes(eachOfNode, rdfTypeSet) {
    const tripleExprs = eachOfNode.instance.expressions;
    tripleExprs.forEach((tripleExpr) => {
        if (typeof tripleExpr === "object" &&
            tripleExpr.type === "TripleConstraint" &&
            tripleExpr.predicate ===
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" &&
            typeof tripleExpr.valueExpr === "object" &&
            tripleExpr.valueExpr.type === "NodeConstraint" &&
            tripleExpr.valueExpr.values) {
            tripleExpr.valueExpr.values.forEach((val) => {
                if (typeof val === "string")
                    rdfTypeSet.add(val);
            });
        }
    });
    eachOfNode.parent("tripleExpr").forEach((tripleExprNode) => {
        const tripleExprOrRefNodes = tripleExprNode.parent("tripleExprOrRef");
        tripleExprOrRefNodes.forEach((tripleExprOrRdfNode) => {
            const parentEachOfs = tripleExprOrRdfNode.parent("EachOf", "expressions");
            parentEachOfs.forEach((parentEachOf) => {
                recursivelyGatherTypesFromEachOfNodes(parentEachOf, rdfTypeSet);
            });
            const parentShapes = tripleExprOrRdfNode.parent("Shape", "expression");
            parentShapes.forEach((parentShape) => recursivelyGatherTypesFromShapeNodes(parentShape, rdfTypeSet));
        });
    });
}
function getRdfTypesForTripleConstraint(tripleConstraintNode) {
    const rdfTypeSet = new Set();
    tripleConstraintNode.parent("tripleExpr").forEach((tripleExprParents) => {
        tripleExprParents
            .parent("tripleExprOrRef")
            .forEach((tripleExprOrRefParent) => {
            tripleExprOrRefParent
                .parent("EachOf", "expressions")
                .forEach((eachOfParent) => {
                recursivelyGatherTypesFromEachOfNodes(eachOfParent, rdfTypeSet);
            });
        });
    });
    const rdfTypes = rdfTypeSet.size > 0 ? Array.from(rdfTypeSet) : [undefined];
    return rdfTypes;
}
exports.getRdfTypesForTripleConstraint = getRdfTypesForTripleConstraint;
//# sourceMappingURL=getRdfTypesForTripleConstraint.js.map